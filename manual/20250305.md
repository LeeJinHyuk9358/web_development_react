# TypeScript 상에서의 함수

형식 :

```ts
// 함수 정의
function sayHello(name: string) {
  console.log('Hello ' + name);
}

// 함수 호출
```

- 다른 자료형으로 argument를 넣게 되면 오류가 발생하게 될겁니다.

또한 함수 매개변수에 유니언 타입을 이용하는 것도 가능

```ts
function checkId(id: string | number) {
  if(typeof id === 'string') {
    //구현부
  } else {
    //구현부
  }
}
```

- 함수의 return 타입을 정의하는 방법

```ts
function calcSum(x: number, y: number): number {
  return
}
```

- 이상의 내용들을 합쳐서 화살표 함수로도 변형이 가능합니다.
- call3(), call4() 유형인 경우에 사용하는 방식
```ts
const calcSum = (x:number, y:number): number => x + y;
```
- call1(), call2() -> void
아까 위에서 정의한 sayHello() 함수를 sayHello2()로 작성하여 콘솔창에 Hello, Kimil을 출력하시오.

```ts
const sayHello2 = (name: string): void => console.log('Hello, ' + name);

sayHello2('Kimil');
```

# React 에서의 TS 기능 이용

- 타입스크립트는 특히 프로젝트가 복잡해질 때 리액트 프로젝트에서 유용한 '추가 요소'다. 이번 컴포넌트에서 프롭과 상태 타입 유효성 검사를 수행하고 개발 초기에 잠재적인 오류를 감지하는 방법에 대해 수업할 예정(runtime시가 아니라).

## state / props
리액트에서는 컴포넌트 프롭의 타입을 정의해야 하는데, 이전에서의 수업에서 컴포넌트의 프롭이 자바스크립트의 객체에 해당한다고 했습니다. 즉 우리는 어제 배운 TS에서는 type 또는 interface를 이용할 수 있습니다.

예시

```jsx
function HelloComponent( {name, age}) {
  return(
    <>
      Hello {name}, you are {age} years old!
    </>
  );
}

export default HelloComponent;

function App() {
  return(
    <HelloComponent name="Ahn" age={12} />
  );
}
```
와 같은 방식으로 리액트에서 실행할 수 있습니다.

- 이를 타입스크립트를 활용하는 경우에는 먼저 프롭을 설명하는 타입을 만드는 것부터 시작하는 것이 가능

```ts
type HelloProps = {
  name: string;
  age: number;
}

// 이후 컴포넌트 프룹에 HelloProps를 이용하는 것이 가능
function HelloComponent({name, age}: HelloProps) {
  return(
    <>
      Hello {name}, you are {age} years old!
    </>
  );
}

export default HelloComponent;
```

- 이상의 TS를 사용했을 경우 이제 type 내부에 있는 key에 잘못된 자료형의 argument를 명시했을 경우 오류가 발생하게 됩니다. JS에서는 숫자 대신 문자열을 age 프롭으로 전달했더라도 알아서 작동했겠지만, 추후 수학 연산을 하려고 했을 때서야 문제가 발생하게 된다는 점에서 디버깅에서의 어려움이 있을 수 있습니다.

- 그리고 어제 학습한 선택 사항인 경우 

```ts
type HelloProps = {
  name: string;
  age?: number;
}
```

- 이상의 경우

```ts
function HelloComponent({name, age}: HelloProps) {
  return(
    <>
      Hello {name}, you are {age} years old!
    </>
  );
}

export default HelloComponent;

function App() {
  return(
    <HelloComponent name="Ahn" />
  );
}
```

- 해당 경우 age 프롭이 있든 없든 컴포넌트의 실행이 가능

### 프롭을 이용하여 함수를 전달하는 방법

```ts
// 매개변수가 없는 함수
type HelloProps = {
  name: string;
  age: number;
  fn: () => void;
}

// 매개변수가 있는 함수
type HelloProps = {
  name: string;
  age: number;
  fn: (msg: string) => void;
}
```

### useState 훅을 이용하여 상태를 생성했을 때의 예시

```jsx
// boolean
const [isReady, setIsReady] = useState(false);
// string
const [message, setMessage] = useState('');
// number
const [const, setCount] = useState(0);
```

- 라고 useState를 학습했을 때, useState(initialValue);라는 표현을 썼습니다.
그런데, 이하의 경우 오류가 발생합니다.

```jsx
setCount('Hello');
```

- 그래서 이상과 같은(initialValue와 추후 argument간의 자료형 불일치) 문제를 해결하기 위해서 상태 타입을 명시적으로 정의하는 것이 가능합니다. 상태를 null 혹은 undefined로 초기화하려면 유니언 연산자를 사용해야 합니다.

예시

```ts
const [message, setMessage] = useState<string | undefined>(undefined);
```

- 복잡한 구조의 상태라면 type / interface를 사용하는 것도 가능.

```ts
type User = {
  id: number;
  name: string;
  email: string;
}

// 타입을 상태와 함께 활용하고자 할 때 초기값으로 아무 것도 있지 않은 User 객체를 이용
const [user, setUser]= useState({} as User);

// null 값을 넣었을 때는
const [user, setUser] = userState<User | null>(null);
```